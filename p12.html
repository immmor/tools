<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>简易手动修脸工具</title>
    <style>
        body { font-family: sans-serif; background: #f0f2f5; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        .controls { background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px; display: flex; gap: 20px; align-items: center; }
        canvas { background: #ddd; cursor: crosshair; box-shadow: 0 4px 20px rgba(0,0,0,0.2); max-width: 90vw; }
        .btn { padding: 8px 16px; cursor: pointer; background: #007bff; color: white; border: none; border-radius: 4px; }
        .btn:hover { background: #0056b3; }
        label { font-size: 14px; font-weight: bold; }
    </style>
</head>
<body>

    <h2>手动修脸/液化工具</h2>

    <div class="controls">
        <input type="file" id="upload" accept="image/*">
        
        <div>
            <label>画笔大小:</label>
            <input type="range" id="radius" min="10" max="100" value="50">
        </div>
        
        <div>
            <label>强度:</label>
            <input type="range" id="strength" min="1" max="50" value="20">
        </div>

        <button class="btn" id="save">保存图片</button>
        <button class="btn" style="background:#6c757d" onclick="location.reload()">重置</button>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const upload = document.getElementById('upload');
        const radiusInput = document.getElementById('radius');
        const strengthInput = document.getElementById('strength');
        const saveBtn = document.getElementById('save');

        let imgData = null; // 原始数据
        let workingData = null; // 实时处理数据
        let isDrawing = false;
        let lastX, lastY;

        // 加载图片
        upload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    workingData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        // 核心液化算法：前向映射变形
        function movePixels(startX, startY, endX, endY) {
            const radius = parseInt(radiusInput.value);
            const strength = parseInt(strengthInput.value) / 100;
            
            const dx = endX - startX;
            const dy = endY - startY;
            const distMax = radius * radius;

            const tempData = ctx.createImageData(canvas.width, canvas.height);
            tempData.data.set(workingData.data);

            // 局部区域优化，只计算画笔附近的像素
            const minX = Math.max(0, Math.floor(startX - radius));
            const minY = Math.max(0, Math.floor(startY - radius));
            const maxX = Math.min(canvas.width, Math.ceil(startX + radius));
            const maxY = Math.min(canvas.height, Math.ceil(startY + radius));

            for (let y = minY; y < maxY; y++) {
                for (let x = minX; x < maxX; x++) {
                    const diX = x - startX;
                    const diY = y - startY;
                    const distSq = diX * diX + diY * diY;

                    if (distSq < distMax) {
                        const dist = Math.sqrt(distSq);
                        // 计算形变权重 (余弦函数平滑过渡)
                        const weight = (1 - dist / radius);
                        const moveX = dx * weight * strength;
                        const moveY = dy * weight * strength;

                        // 寻找源像素位置
                        const srcX = Math.round(x - moveX);
                        const srcY = Math.round(y - moveY);

                        if (srcX >= 0 && srcX < canvas.width && srcY >= 0 && srcY < canvas.height) {
                            const targetIdx = (y * canvas.width + x) * 4;
                            const srcIdx = (srcY * canvas.width + srcX) * 4;

                            workingData.data[targetIdx] = tempData.data[srcIdx];
                            workingData.data[targetIdx+1] = tempData.data[srcIdx+1];
                            workingData.data[targetIdx+2] = tempData.data[srcIdx+2];
                            workingData.data[targetIdx+3] = tempData.data[srcIdx+3];
                        }
                    }
                }
            }
            ctx.putImageData(workingData, 0, 0);
        }

        // 鼠标事件
        canvas.onmousedown = (e) => {
            isDrawing = true;
            [lastX, lastY] = [e.offsetX, e.offsetY];
        };

        window.onmousemove = (e) => {
            if (!isDrawing) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            movePixels(lastX, lastY, x, y);
            [lastX, lastY] = [x, y];
        };

        window.onmouseup = () => isDrawing = false;

        // 保存图片
        saveBtn.onclick = () => {
            const link = document.createElement('a');
            link.download = 'edited_face.png';
            link.href = canvas.toDataURL();
            link.click();
        };
    </script>
</body>
</html>