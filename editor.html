<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>immmor code</title>
    <link rel="icon" type="image/png" href="iwe.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <style>
        :root {
            --amber: #ffb000;
            --amber-dim: #714e00;
            --bg: #12100b;
            --panel-bg: #1c1912;
            --border-w: 2px;
            --term-red: #ff3e3e;
            --term-green: #00ff41;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; cursor: default; }
        
        body, html {
            margin: 0; padding: 0; height: 100vh; width: 100vw;
            background: var(--bg); color: var(--amber);
            font-family: 'Courier New', Courier, monospace; overflow: hidden;
            background-image: linear-gradient(rgba(18, 16, 11, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 255, 0, 0.06));
            background-size: 100% 4px, 3px 100%;
        }

        .header {
            height: 40px; border-bottom: var(--border-w) solid var(--amber);
            display: flex; align-items: center; padding: 0 15px;
            font-size: 14px; font-weight: bold; background: var(--panel-bg);
            text-shadow: 0 0 5px var(--amber); gap: 20px;
        }

        .menu-btn { cursor: pointer !important; padding: 5px 10px; border: 1px solid transparent; }
        .menu-btn:hover { border-color: var(--amber); background: rgba(255, 176, 0, 0.1); }

        .workspace { display: flex; flex-direction: row; height: calc(100vh - 40px); width: 100%; position: relative; }

        .panel { 
            background: var(--panel-bg); display: flex; flex-direction: column; 
            overflow: hidden; position: relative; height: 100%;
        }

        .panel.maximized {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;   /* å¿…é¡»è®¾ä¸º0ï¼Œç¡®ä¿ä»å±å¹•æœ€å·¦è¾¹å¼€å§‹ */
            width: 100vw !important; /* å æ®æ•´ä¸ªå±å¹•å®½åº¦ */
            height: 100vh !important; /* å æ®æ•´ä¸ªå±å¹•é«˜åº¦ */
            z-index: 999999 !important; /* ç¡®ä¿å±‚çº§é«˜äºä¸€åˆ‡ */
            background: var(--bg) !important; /* èƒŒæ™¯ä¸é€æ˜ï¼Œé®ä½åº•ä¸‹çš„ç¼–è¾‘å™¨ */
            display: flex !important;
            flex-direction: column !important;
            margin: 0 !important;
            padding: 0 !important;
        }

        .divider-h { width: 6px; background: var(--amber-dim); cursor: col-resize !important; flex-shrink: 0; }
        .divider-h:hover, .divider-h.active { background: var(--amber); box-shadow: 0 0 10px var(--amber); }

        .divider-v { height: 6px; background: var(--amber-dim); cursor: row-resize !important; flex-shrink: 0; }
        .divider-v:hover, .divider-v.active { background: var(--amber); box-shadow: 0 0 10px var(--amber); }

        .p-head {
            height: 30px; border-bottom: 1px solid var(--amber-dim);
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 10px; font-size: 11px; background: rgba(113, 78, 0, 0.1);
        }
        .ctrl-group { display: flex; gap: 5px; }
        .ctrl { cursor: pointer !important; padding: 2px 6px; border: 1px solid var(--amber-dim); }
        .ctrl:hover { background: var(--amber); color: var(--bg); }

        #explorer { 
            width: 200px; 
            border-right: 1px solid var(--amber-dim); 
            display: flex; 
            flex-direction: column; 
            overflow: hidden;
        }
        #file-section, #plugin-section {
            min-height: 0;
            overflow: hidden;
        }
        #file-list, #plugin-list { overflow-y: auto; flex: 1; }
        #plugin-section { 
            flex: 1; 
            display: flex; 
            flex-direction: column; 
            min-height: 50px;
        }
        .file-item, .plugin-item { 
            padding: 8px 15px; font-size: 13px; cursor: pointer !important; 
            border-bottom: 1px solid rgba(113, 78, 0, 0.05); 
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            display: flex; align-items: center; 
            color: var(--amber); opacity: 0.7; 
        }
        .file-item:hover, .plugin-item:hover { background: rgba(255, 176, 0, 0.05); opacity: 0.9; }
        .file-item.active { background: var(--amber); color: var(--bg) !important; font-weight: bold; opacity: 1; }
        .file-item.folder { color: var(--amber); font-weight: bold; opacity: 1; border-left: 2px solid var(--amber-dim); }

        .plugin-item { justify-content: space-between; font-size: 11px; }
        .plugin-status { width: 8px; height: 8px; border-radius: 50%; background: var(--amber-dim); }
        .plugin-status.active { background: var(--term-green); box-shadow: 0 0 5px var(--term-green); }

        .file-rename-input {
            background: var(--amber); color: var(--bg); border: none; outline: none;
            font-family: inherit; font-size: 13px; width: 100%; padding: 0; margin: 0; font-weight: bold;
        }

        #main-stack { flex: 1; display: flex; flex-direction: column; min-width: 0; }
        #editor {
            flex: 1; background: transparent; border: none; outline: none;
            padding: 20px; color: var(--amber); font-size: 16px;
            line-height: 1.5; resize: none; font-family: inherit; cursor: text !important;
        }

        #terminal { height: 220px; }
        .term-tabs { display: flex; background: #000; border-bottom: 1px solid var(--amber-dim); overflow-x: auto; scrollbar-width: none; }
        .term-tabs::-webkit-scrollbar { display: none; }
        .term-tab { 
            padding: 5px 12px; font-size: 10px; border-right: 1px solid var(--amber-dim); 
            cursor: pointer !important; opacity: 0.6; display: flex; align-items: center; gap: 8px; 
            white-space: nowrap;
        }
        #term-tabs .term-tab:only-child .term-close,
        #ai-tabs .term-tab:only-child .term-close {
            display: none !important;
        }
        .term-tab.active { background: var(--amber-dim); color: #fff; opacity: 1; }
        .term-close { font-size: 12px; font-weight: bold; cursor: pointer !important; color: var(--term-red); }
        .term-close:hover { color: #fff; }
        
        .term-body { flex: 1; display: none; flex-direction: column; overflow: hidden; }
        .term-body.active { display: flex; }
        .term-out { flex: 1; padding: 10px; overflow-y: auto; font-size: 12px; color: rgba(255, 176, 0, 0.8); white-space: pre-wrap; word-break: break-all; }
        .term-input-wrap { display: flex; padding: 8px 10px; background: #000; border-top: 1px solid var(--amber-dim); gap: 10px; align-items: center; }
        .cmd-in { background: transparent; border: none; outline: none; flex: 1; color: #fff; font-family: inherit; cursor: text !important; }

        #ai-panel { width: 280px; border-left: 1px solid var(--amber-dim); }
        #ai-chat { flex: 1; padding: 15px; overflow-y: auto; font-size: 13px; scroll-behavior: smooth; }
        
        .msg { margin-bottom: 15px; line-height: 1.4; border-left: 2px solid var(--amber-dim); padding-left: 10px; word-wrap: break-word; overflow-wrap: break-word; white-space: pre-wrap; }
        .msg.ai { border-left-color: var(--amber); }
        .msg.user { color: #fff; opacity: 0.8; }
        
        .ai-tools { padding: 8px 10px; background: rgba(113, 78, 0, 0.1); border-top: 1px solid var(--amber-dim); font-size: 10px; position: relative; }
        
        .custom-select-trigger { 
            background: #000; color: var(--amber); border: 1px solid var(--amber-dim); 
            font-size: 10px; width: 100%; padding: 6px; cursor: pointer !important;
            display: flex; justify-content: space-between; align-items: center; white-space: nowrap;
        }
        .custom-select-trigger.active span:last-child {
            transform: rotate(180deg);
        }
        .custom-select-options {
            position: absolute; bottom: 100%; left: 10px; right: 10px; background: var(--panel-bg);
            border: 1px solid var(--amber); display: none; z-index: 600; max-height: 200px; overflow-y: auto;
        }
        .custom-select-options div { padding: 8px; border-bottom: 1px solid var(--amber-dim); cursor: pointer !important; }
        .custom-select-options div:hover { background: var(--amber); color: #000; }

        .ai-input-area { padding: 10px; background: rgba(0,0,0,0.3); border-top: 1px solid var(--amber-dim); display: flex; gap: 5px; }
        #ai-in { background: transparent; border: 1px solid var(--amber-dim); color: #fff; flex: 1; padding: 5px; outline: none; cursor: text !important; }
        .ai-btn { background: var(--amber-dim); color: #fff; border: none; padding: 5px 10px; cursor: pointer !important; font-size: 10px; }
        .ai-btn:hover { background: var(--amber); color: var(--bg); }

        #ai-container .msg {
            font-size: 12px; /* åŸæœ¬å¯èƒ½æ˜¯ 16px æˆ– 13pxï¼Œè¿™é‡Œè°ƒå° */
            margin-bottom: 10px;
        }

        .search-res-item {
            padding: 5px 10px; font-size: 11px;
            border-bottom: 1px solid rgba(113, 78, 0, 0.1);
            cursor: pointer !important;
        }
        .search-res-item:hover { background: rgba(255, 176, 0, 0.1); }
        .search-match { color: #fff; background: var(--amber-dim); padding: 0 2px; }
        .search-path { font-size: 9px; opacity: 0.5; display: block; margin-bottom: 2px; }

        .inject-btn { display: inline-block; margin-top: 8px; font-size: 9px; padding: 2px 6px; border: 1px solid var(--amber); cursor: pointer !important; color: var(--amber); }
        .inject-btn:hover { background: var(--amber); color: #000; }

        #ctx, #plugin-ctx, .custom-modal {
            position: fixed; display: none; background: var(--panel-bg);
            border: 2px solid var(--amber); z-index: 1000; min-width: 200px;
            box-shadow: 8px 8px 0px #000;
        }
        .opt { padding: 12px 15px; font-size: 12px; font-weight: bold; cursor: pointer !important; }
        .opt:hover { background: var(--amber); color: var(--bg); }
        .opt.disabled { opacity: 0.5; pointer-events: none; }

        .modal-overlay {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.8); z-index: 2000; display: none;
            align-items: center; justify-content: center;
        }
        .custom-modal { display: block; position: relative; width: 320px; }
        .modal-body { padding: 20px; }
        .modal-input { width: 100%; background: #000; border: 1px solid var(--amber); color: #fff; padding: 8px; outline: none; font-family: inherit; margin-top: 10px; margin-bottom: 15px; }
        .modal-btns { display: flex; justify-content: flex-end; gap: 10px; margin-top: 5px; }
        
        .type-selector { display: flex; gap: 15px; margin-bottom: 10px; font-size: 11px; }
        .type-opt { cursor: pointer !important; display: flex; align-items: center; gap: 5px; }
        .type-opt input { cursor: pointer !important; accent-color: var(--amber); }

        .editor-tools {
            display: flex; gap: 2px; padding: 5px;
            background: rgba(28, 25, 18, 0.8);
            border-bottom: 1px solid var(--amber-dim);
            overflow-x: auto; white-space: nowrap;
            scrollbar-width: none;
        }
        .editor-tools::-webkit-scrollbar { display: none; }
        .key-btn {
            padding: 4px 12px;
            background: var(--bg);
            border: 1px solid var(--amber-dim);
            color: var(--amber);
            font-size: 11px;
            cursor: pointer !important;
            text-transform: uppercase;
        }
        .key-btn:active {
            background: var(--amber);
            color: var(--bg);
        }
    </style>
</head>
<body>

<div class="header">
    <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
        <div style="display: flex; gap: 0px;">
            <div class="menu-btn" onclick="handleCtx(event, 10, 40)">FILE</div>
            <div class="menu-btn" onclick="saveZip()">ARCHIVE</div>
            <div class="menu-btn" onclick="clearTerm()">RESET</div>
        </div>
        <div style="text-shadow: 0 0 10px var(--amber); padding-right:10px;">IMMMOR</div>
    </div>
</div>

<div class="workspace">
    <aside class="panel" id="explorer">
        <div id="file-section" style="height: 50%; display:flex; flex-direction:column; overflow:hidden;">  
            <div class="p-head">
                <span>FILESYSTEM</span>
                <div class="ctrl-group">
                    <span class="ctrl" onclick="toggleSearch()" title="SEARCH_ALL">âŒ•</span>
                    <span class="ctrl" onclick="openModal()" title="NEW NODE">+</span>
                    <span class="ctrl" onclick="toggleExplorerMax('file-section')">â—°</span>
                </div>
            </div>
            <div id="search-container" style="display:none; padding: 10px; border-bottom: 1px solid var(--amber-dim);">
                <input type="text" id="global-search-in" class="modal-input" placeholder="Search files/code..." style="margin:0; font-size:11px;" oninput="executeGlobalSearch()">
            </div>
            <div id="file-list"></div>
            <div id="search-results" style="display:none; overflow-y:auto; flex:1;"></div>
        </div>

        <div class="divider-v" id="v-drag-explorer"></div>

        <div id="plugin-section" style="flex: 1; display:flex; flex-direction:column; overflow:hidden;">
            <div class="p-head">
                <span>PLUGINS</span>
                <div class="ctrl-group">
                    <span class="ctrl" onclick="openPluginModal()" title="ADD PLUGIN">+</span>
                    <span class="ctrl" onclick="toggleExplorerMax('plugin-section')">â—°</span>
                </div>
            </div>
            <div id="plugin-list"></div>
        </div>
    </aside>

    <div class="divider-h" id="h-drag-left"></div>

    <div id="main-stack">
        <main class="panel" id="editor-p" style="flex:1">
            <div class="p-head">
                <span>EDITOR</span>
                <div class="ctrl-group">
                    <span class="ctrl" onclick="runCurrentFile()" title="RUN_NODE" style="color:var(--amber)">â–¶</span>
                    <span class="ctrl" onclick="toggleMax('editor-p')">â—°</span>
                </div>
            </div>
            <div class="term-tabs" id="editor-tabs"></div>
            <div class="editor-tools">
                <div class="key-btn" onclick="saveCurrentFile()">SAVE</div>
                <div class="key-btn" onclick="insertAtCursor('\t')">TAB</div>
                <div class="key-btn" onclick="execEditorCmd('undo')">UNDO</div>
                
                <div class="key-btn" onclick="editorAction('selectAll')"">ALL</div>
                <div class="key-btn" onclick="editorAction('cut')">CUT</div>
                <div class="key-btn" onclick="editorAction('copy')">COPY</div>
                <div class="key-btn" onclick="editorAction('paste')">PASTE</div>

                <div class="key-btn" onclick="insertAtCursor('{}', 1)">{ }</div>
                <div class="key-btn" onclick="insertAtCursor('()', 1)">( )</div>
                <div class="key-btn" onclick="insertAtCursor('[]', 1)">[ ]</div>
                <div class="key-btn" onclick="insertAtCursor('\'\'', 1)">' '</div>
            </div>
            <div id="editor-container" style="flex:1; display:flex; flex-direction:column; overflow:hidden;"></div>
        </main>
        
        <div class="divider-v" id="v-drag"></div>

        <footer class="panel" id="terminal">
    <div class="p-head">
        <span>COMMAND</span>
        <div class="ctrl-group">
            <span class="ctrl" onclick="addTerminal()">+</span>
            <span class="ctrl" onclick="toggleMax('terminal')">â—°</span>
        </div>
    </div>
    <div class="editor-tools">
        <div class="key-btn" onclick="insertAtTerm('\t')">TAB</div>
        <div class="key-btn" onclick="execTermUndo()">UNDO</div>
        
        <div class="key-btn" onclick="termAction('selectAll')">ALL</div>
        <div class="key-btn" onclick="termAction('cut')">CUT</div>
        <div class="key-btn" onclick="termAction('copy')">COPY</div>
        <div class="key-btn" onclick="termAction('paste')">PASTE</div>

        <div class="key-btn" onclick="insertAtTerm('{}', 1)">{ }</div>
        <div class="key-btn" onclick="insertAtTerm('()', 1)">( )</div>
        <div class="key-btn" onclick="insertAtTerm('[]', 1)">[ ]</div>
        <div class="key-btn" onclick="insertAtTerm('\'\'', 1)">' '</div>
    </div>
    <div class="term-tabs" id="term-tabs"></div>
    <div id="term-container" style="flex:1; display:flex; flex-direction:column; overflow:hidden;"></div>
</footer>
    </div>

    <div class="divider-h" id="h-drag-right"></div>

    <aside class="panel" id="ai-panel">
    <div class="p-head">
        <span>AI</span>
        <div class="ctrl-group">
            <span class="ctrl" onclick="addAiTab(true)" title="NEW CHAT">+</span>
            <span class="ctrl" onclick="openHistoryManager()" title="MANAGE HISTORY">â‰¡</span>
            <span class="ctrl" onclick="openSettings()" title="CONFIG">âš™</span>
            <span class="ctrl" onclick="toggleMax('ai-panel')">â—°</span>
        </div>
    </div>
    <div class="term-tabs" id="ai-tabs"></div>
    
    <div id="ai-container" style="flex:1; display:flex; flex-direction:column; overflow:hidden;">
        </div>

    <div class="ai-tools">
    <div style="margin-bottom: 10px;">
        <label style="display:block; margin-bottom:5px">AI_PROVIDER:</label>
        <div class="custom-select-trigger" id="ai-provider-trigger" onclick="toggleProviderSelect()">
            <span id="active-provider-name">---</span>
            <span>â–¼</span>
        </div>
        <div class="custom-select-options" id="ai-provider-options"></div>
    </div>

    <label style="display:block; margin-bottom:5px">CONTEXT_NODE:</label>
    <div class="custom-select-trigger" id="ai-ctx-trigger" onclick="toggleAiSelect()">
        <span id="ai-ctx-val">-- NO_CONTEXT --</span>
        <span>â–¼</span>
    </div>
    <div class="custom-select-options" id="ai-ctx-options"></div>
</div>
    <div class="ai-input-area">
        <input type="text" id="ai-in" placeholder="Query..." autocomplete="off">
        <button class="ai-btn" id="ai-send-btn" onclick="handleAiSend()">SEND</button>
    </div>
</aside>
</div>

<div id="ctx">
    <div class="opt" id="ctx-new-node" onclick="openModal()">[+] NEW_DATA_NODE</div>
    <div class="opt" id="ctx-rename" onclick="startRenameFromCtx()">[R] RENAME_NODE</div>
    <div class="opt" id="ctx-delete" onclick="deleteNodeFromCtx()" style="color:var(--term-red)">[X] DELETE_NODE</div>
    <div class="opt" id="ctx-copy-path" onclick="copyPathFromCtx()">[C] COPY_PATH</div>
    <div style="border-top:1px solid var(--amber-dim); margin:4px 0;"></div>
    <div class="opt" onclick="saveActive()">DOWNLOAD_ACTIVE_NODE</div>
    <div class="opt" onclick="saveZip()">ARCHIVE_ALL_NODES</div>
    <div class="opt" onclick="clearTerm()">RESET_CONSOLE</div>
</div>

<div id="plugin-ctx">
    <div class="opt" onclick="startEditPlugin()">[E] EDIT_PLUGIN</div>
    <div class="opt" onclick="confirmDeletePlugin()" style="color:var(--term-red)">[X] UNINSTALL_PLUGIN</div>
</div>

<div id="modal-overlay" class="modal-overlay">
    <div class="custom-modal">
        <div class="p-head"><span id="modal-title">SYSTEM_PROMPT</span></div>
        <div class="modal-body" id="modal-content"></div>
    </div>
</div>

<script>
    let storage = JSON.parse(localStorage.getItem('ind_console_storage')) || {
        'PROTOCOL.txt': 'SYSTEM OVERRIDE: ACTIVE\nENCRYPTION: ENABLED',
        'script.js': 'console.log("Node WASM active");',
        'main.py': 'print("Python WASM initialized")'
    };
    let plugins = JSON.parse(localStorage.getItem('ind_console_plugins')) || [
        { 
            name: 'Matrix_Rain', 
            code: 'const canvas = document.createElement(\'canvas\');const ctx = canvas.getContext(\'2d\');canvas.id = \'matrix-canvas\';canvas.style.cssText = \'position:fixed;top:0;left:0;width:100%;height:100%;z-index:22;opacity:0.4;pointer-events:none;\';document.body.appendChild(canvas);let w = canvas.width = window.innerWidth;let h = canvas.height = window.innerHeight;const chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ$+-*/=<>!%";const fontSize = 14;const columns = Math.floor(w / fontSize);const drops = new Array(columns).fill(1);function draw() { ctx.fillStyle = \'rgba(18, 16, 11, 0.05)\'; ctx.fillRect(0, 0, w, h); ctx.fillStyle = \'#ffb000\'; ctx.font = fontSize + \'px "Courier New"\'; for (let i = 0; i < drops.length; i++) { const text = chars[Math.floor(Math.random() * chars.length)]; ctx.fillText(text, i * fontSize, drops[i] * fontSize); if (drops[i] * fontSize > h && Math.random() > 0.975) drops[i] = 0; drops[i]++; } }const interval = setInterval(draw, 33);const resizeHandler = () => { w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight; };window.addEventListener(\'resize\', resizeHandler);return () => { clearInterval(interval); window.removeEventListener(\'resize\', resizeHandler); if (canvas.parentNode) canvas.parentNode.removeChild(canvas); };', 
            active: false 
        }
    ];
    let config = JSON.parse(localStorage.getItem('ind_console_config')) || {
        activeProviderIndex: 0,
        providers: [
            {
                name: 'Gemini Default',
                apiBaseUrl: 'https://mrok.dpdns.org/v1',
                apiKey: '',
                model: 'gemini-flash-latest'
            }
        ]
    };
    let selectedProviderIndices = [config.activeProviderIndex]; // åªæ”¯æŒå•ä¸ªä¾›åº”å•†
    let aiChatHistory = JSON.parse(localStorage.getItem('ind_console_ai_history')) || {};
    let activeFile = localStorage.getItem('ind_console_active') || 'PROTOCOL.txt';
    let expandedDirs = JSON.parse(localStorage.getItem('ind_console_expanded')) || ['SYSTEM/'];
    let termCount = 0;
    let activeTermId = null;
    let selectedAiCtx = 'none';
    let pyodideInstance = null;
    let ctxTarget = null;
    let pluginCtxTarget = null;
    
    // ç¼–è¾‘é¢æ¿å¤šæ ‡ç­¾ç®¡ç†
    let editorTabs = {};
    let activeEditorTab = null;

    let isSearching = false;
    function toggleSearch() {
        const searchCont = document.getElementById('search-container');
        const fileList = document.getElementById('file-list');
        const searchRes = document.getElementById('search-results');
        const searchInput = document.getElementById('global-search-in');

        isSearching = !isSearching;

        if (isSearching) {
            searchCont.style.display = 'block';
            searchRes.style.display = 'block';
            fileList.style.display = 'none';
            searchInput.focus();
        } else {
            searchCont.style.display = 'none';
            searchRes.style.display = 'none';
            fileList.style.display = 'block';
            searchInput.value = '';
        }
    }

    function executeGlobalSearch() {
        const query = document.getElementById('global-search-in').value.toLowerCase();
        const resultsCont = document.getElementById('search-results');
        resultsCont.innerHTML = '';

        if (!query) return;

        Object.keys(storage).forEach(path => {
            const isFolder = path.endsWith('/');
            const content = storage[path];
            
            // 1. æœç´¢æ–‡ä»¶å
            const fileNameMatch = path.toLowerCase().includes(query);
            
            // 2. æœç´¢æ–‡ä»¶å†…å®¹ (å¦‚æœæ˜¯æ–‡ä»¶)
            let contentMatch = null;
            if (!isFolder && typeof content === 'string') {
                const index = content.toLowerCase().indexOf(query);
                if (index !== -1) {
                    // æˆªå–åŒ¹é…é¡¹å‰åçš„ä¸Šä¸‹æ–‡
                    const start = Math.max(0, index - 20);
                    const end = Math.min(content.length, index + query.length + 20);
                    contentMatch = content.substring(start, end).replace(/\n/g, ' ');
                }
            }

            if (fileNameMatch || contentMatch) {
                const div = document.createElement('div');
                div.className = 'search-res-item';
                
                // æ¸²æŸ“ç»“æœé¡¹
                let innerHTML = `<span class="search-path">${path}</span>`;
                if (contentMatch) {
                    // é«˜äº®æ˜¾ç¤ºåŒ¹é…çš„å†…å®¹ç‰‡æ®µ
                    const highlighted = contentMatch.replace(new RegExp(query, 'gi'), (m) => `<span class="search-match">${m}</span>`);
                    innerHTML += `<span style="opacity:0.8">...${highlighted}...</span>`;
                } else {
                    innerHTML += `<span style="color:var(--amber)">[MATCH_IN_FILENAME]</span>`;
                }

                div.innerHTML = innerHTML;
                div.onclick = () => {
                    // è‡ªåŠ¨æ‰“å¼€å¯¹åº”æ–‡ä»¶
                    activeFile = path;
                    if (!isFolder) {
                        document.getElementById('editor').value = storage[path];
                        document.getElementById('cur-filename').innerText = path;
                    }
                    toggleSearch(); // æœç´¢å®Œæˆååˆ‡æ¢å›æ–‡ä»¶åˆ—è¡¨
                    renderFiles();
                };
                resultsCont.appendChild(div);
            }
        });

        if (resultsCont.innerHTML === '') {
            resultsCont.innerHTML = '<div style="padding:10px; font-size:10px; opacity:0.5;">NO_MATCHES_FOUND</div>';
        }
    }

// ç»ˆç«¯å­—ç¬¦æ’å…¥å‡½æ•° (æ”¯æŒæ‹¬å·åç§»)
function insertAtTerm(text, offset = 0) {
    if (!activeTermId) return;
    const input = document.getElementById(activeTermId).querySelector('.cmd-in');
    if (!input) return;

    const start = input.selectionStart;
    const end = input.selectionEnd;
    input.value = input.value.substring(0, start) + text + input.value.substring(end);

    const newPos = start + text.length - offset;
    input.focus();
    input.setSelectionRange(newPos, newPos);
}

// ç¼–è¾‘å™¨å…¨é€‰ã€å‰ªåˆ‡ã€å¤åˆ¶ã€ç²˜è´´é€»è¾‘
async function editorAction(action) {
    const el = document.getElementById('editor');
    el.focus();
    if (action === 'selectAll') {
        el.select();
    } else if (action === 'copy') {
        const selectedText = el.value.substring(el.selectionStart, el.selectionEnd);
        await navigator.clipboard.writeText(selectedText);
    } else if (action === 'cut') {
        const selectedText = el.value.substring(el.selectionStart, el.selectionEnd);
        await navigator.clipboard.writeText(selectedText);
        document.execCommand('delete');
    } else if (action === 'paste') {
        try {
            const text = await navigator.clipboard.readText();
            insertAtCursor(text);
        } catch (err) {
            addLog("PASTE_ERROR: Permission denied", "var(--term-red)");
        }
    }
}

// ç»ˆç«¯è¾“å…¥æ¡†å…¨é€‰ã€å‰ªåˆ‡ã€å¤åˆ¶ã€ç²˜è´´é€»è¾‘
async function termAction(action) {
    if (!activeTermId) return;
    const input = document.getElementById(activeTermId).querySelector('.cmd-in');
    if (!input) return;
    input.focus();

    if (action === 'selectAll') {
        input.select();
    } else if (action === 'copy') {
        const selectedText = input.value.substring(input.selectionStart, input.selectionEnd);
        await navigator.clipboard.writeText(selectedText);
    } else if (action === 'cut') {
        const selectedText = input.value.substring(input.selectionStart, input.selectionEnd);
        await navigator.clipboard.writeText(selectedText);
        input.value = input.value.substring(0, input.selectionStart) + input.value.substring(input.selectionEnd);
    } else if (action === 'paste') {
        try {
            const text = await navigator.clipboard.readText();
            insertAtTerm(text);
        } catch (err) {
            console.error("Paste failed");
        }
    }
}

// ç»ˆç«¯æ’¤é”€æ“ä½œ
function execTermUndo() {
    if (!activeTermId) return;
    const input = document.getElementById(activeTermId).querySelector('.cmd-in');
    if (input) {
        input.focus();
        document.execCommand('undo', false, null);
    }
}
    // åœ¨å…‰æ ‡å¤„æ’å…¥æ–‡æœ¬
// å¢å¼ºï¼šæ’å…¥æ–‡æœ¬å¹¶åœ¨å¿…è¦æ—¶å¤„ç†å›è½¦ç¼©è¿›
function insertAtCursor(text, offset = 0, isReturn = false) {
    if (activeEditorTab && editorTabs[activeEditorTab]) {
        const el = editorTabs[activeEditorTab].editor;
        const start = el.selectionStart;
        const end = el.selectionEnd;
        const val = el.value;

        let contentToInsert = text;
        
        // å¦‚æœæ˜¯å›è½¦é”®ï¼Œå°è¯•æ¨¡æ‹Ÿç®€å•è‡ªåŠ¨ç¼©è¿›
        if (isReturn) {
            const line = val.substring(0, start).split('\n').pop();
            const trimStart = line.search(/\S/);
            const indent = trimStart > 0 ? line.substring(0, trimStart) : "";
            contentToInsert = '\n' + indent;
        }

        el.value = val.substring(0, start) + contentToInsert + val.substring(end);
        
        const newPos = start + contentToInsert.length - offset;
        el.focus();
        el.setSelectionRange(newPos, newPos);
        
        autoSave();
    }
}


// æ¨¡æ‹Ÿ Ctrl/Shift çš„å¤åˆåŠŸèƒ½ï¼ˆç”±äºç½‘é¡µç«¯é™åˆ¶ï¼Œé€šå¸¸ç”¨äºå¿«é€Ÿé€‰æ‹©æˆ–å¿«æ·é”®ï¼‰
function handleModifier(type) {
    const el = document.getElementById('editor');
    addLog(`[SYSTEM]: MODIFIER_${type}_ACTIVE`, 'var(--amber-dim)');
    el.focus();
    // è¿™é‡Œå¯ä»¥æ ¹æ®éœ€æ±‚æ‰©å±•ï¼Œä¾‹å¦‚ç‚¹å‡» Shift åä¸‹æ¬¡ç‚¹å‡»æ–¹å‘é”®å˜ä¸ºé€‰ä¸­æ¨¡å¼
}
// æ‰§è¡ŒåŸºç¡€ç¼–è¾‘å‘½ä»¤ (Undo/Redo)
function execEditorCmd(cmd) {
    if (activeEditorTab && editorTabs[activeEditorTab]) {
        const editor = editorTabs[activeEditorTab].editor;
        editor.focus();
        document.execCommand(cmd, false, null);
        autoSave();
    }
}

// æ‹¦æˆªç‰©ç† Tab é”® (å¦‚æœæ˜¯å¤–æ¥é”®ç›˜)
function initEditorTabEvents() {
    if (activeEditorTab && editorTabs[activeEditorTab]) {
        const editor = editorTabs[activeEditorTab].editor;
        editor.addEventListener('keydown', function(e) {
            if (e.key === 'Tab') {
                e.preventDefault();
                insertAtCursor('    ');
            }
        });
    }
}

    // --- Plugins Logic ---
    function renderPlugins() {
        const list = document.getElementById('plugin-list');
        list.innerHTML = '';
        plugins.forEach((p, index) => {
            const div = document.createElement('div');
            div.className = 'plugin-item';
            div.innerHTML = `
                <span>${p.name}</span>
                <div class="plugin-status ${p.active ? 'active' : ''}"></div>
            `;
            div.onclick = () => togglePlugin(index);
            div.oncontextmenu = (e) => {
                e.preventDefault();
                e.stopPropagation();
                pluginCtxTarget = index;
                showPluginCtx(e);
            };
            list.appendChild(div);
        });
    }

    function showPluginCtx(e) {
        const pCtx = document.getElementById('plugin-ctx');
        pCtx.style.display = 'block';
        pCtx.style.left = e.pageX + 'px';
        pCtx.style.top = e.pageY + 'px';
    }

    function startEditPlugin() {
        if (pluginCtxTarget === null) return;
        const p = plugins[pluginCtxTarget];
        document.getElementById('plugin-ctx').style.display = 'none';
        
        // ç›´æ¥æ‰“å¼€æ’ä»¶ä»£ç ï¼Œæ ‡ç­¾åå°±æ˜¯æ’ä»¶å
        const pluginTabName = p.name;
        
        if (editorTabs[pluginTabName]) {
            switchEditorTab(pluginTabName);
        } else {
            createEditorTab(pluginTabName);
            editorTabs[pluginTabName].editor.value = p.code;
        }
    }

    async function runCurrentFile() {
    if (!activeFile || activeFile.endsWith('/')) return;

    // è‡ªåŠ¨ä¿å­˜å½“å‰ç¼–è¾‘å™¨å†…å®¹åˆ° storage
    autoSave();

    const fileName = activeFile.toLowerCase();
    
    // ç¡®ä¿æœ‰æ´»è·ƒçš„ç»ˆç«¯ï¼Œå¦‚æœæ²¡æœ‰åˆ™åˆ›å»ºä¸€ä¸ª
    if (!activeTermId) {
        addTerminal();
    }

    // åˆ‡æ¢åˆ°ç»ˆç«¯é¢æ¿è§†å›¾ï¼ˆå¯é€‰ï¼Œä¸ºäº†è®©ç”¨æˆ·çœ‹åˆ°è¾“å‡ºï¼‰
    // document.getElementById('terminal').scrollIntoView();

    addLog(`[SYSTEM]: EXEC_START >> ${activeFile}`, 'var(--amber)');

    if (fileName.endsWith('.js')) {
        // æ‰§è¡Œ JavaScript
        try {
            const code = storage[activeFile];
            // ä½¿ç”¨ Function æ„é€ å‡½æ•°æ‰§è¡Œï¼Œå¹¶æ³¨å…¥ä¸€ä¸ªç®€å•çš„ log ä»£ç†
            new Function('console', code)({
                log: (m) => addLog(m, 'var(--term-green)'),
                error: (m) => addLog(`ERR: ${m}`, 'var(--term-red)')
            });
        } catch (e) {
            addLog(`RUNTIME_ERR: ${e.message}`, 'var(--term-red)');
        }
    } else if (fileName.endsWith('.py')) {
        // æ‰§è¡Œ Python (ä½¿ç”¨ä½ å·²æœ‰çš„ Pyodide é€»è¾‘)
        try {
            addLog("INITIALIZING_PYTHON_WASM...", "var(--amber-dim)");
            const py = await initPython();
            py.setStdout({ batched: (str) => addLog(str, 'var(--term-green)') });
            await py.runPythonAsync(storage[activeFile]);
        } catch (e) {
            addLog(`PYTHON_ERR: ${e.message}`, 'var(--term-red)');
        }
    } else {
        addLog(`ERR: NO_EXECUTOR_FOR_EXTENSION (${activeFile.split('.').pop()})`, 'var(--term-red)');
    }
}

    function confirmDeletePlugin() {
        if (pluginCtxTarget === null) return;
        if(confirm(`UNINSTALL ${plugins[pluginCtxTarget].name}?`)) {
            plugins.splice(pluginCtxTarget, 1);
            savePlugins();
        }
        document.getElementById('plugin-ctx').style.display = 'none';
    }

    function togglePlugin(index) {
        plugins[index].active = !plugins[index].active;
        if (plugins[index].active) {
            try { 
                const pluginReturn = new Function(plugins[index].code)(); 
                plugins[index]._cleanup = typeof pluginReturn === 'function' ? pluginReturn : null;
            } catch(e) { console.error("PLUGIN_BOOT_ERR:", e); }
        } else {
            if (plugins[index]._cleanup) {
                plugins[index]._cleanup();
            } else {
                console.log("REBOOT_REQUIRED: Plugin state persists.");
            }
        }
        savePlugins();
    }

    function savePlugins() {
        localStorage.setItem('ind_console_plugins', JSON.stringify(plugins));
        renderPlugins();
    }

    function openPluginModal() {
        // åˆ›å»ºæ–°æ’ä»¶ç¼–è¾‘æ ‡ç­¾
        const newPluginTabName = "New_Plugin";
        
        if (editorTabs[newPluginTabName]) {
            switchEditorTab(newPluginTabName);
        } else {
            createEditorTab(newPluginTabName);
            editorTabs[newPluginTabName].editor.value = "// æ–°æ’ä»¶ä»£ç \n// ç¼–è¾‘å®ŒæˆåæŒ‰ Ctrl+S æˆ–ç‚¹å‡»ğŸ’¾æŒ‰é’®ä¿å­˜";
        }
    }

    function confirmPlugin() {
        // è¿™ä¸ªå‡½æ•°ç°åœ¨ç”±ç¼–è¾‘å™¨è‡ªåŠ¨ä¿å­˜æ›¿ä»£ï¼Œä¿ç•™ç©ºå®ç°
        console.log('æ’ä»¶åˆ›å»ºå·²æ”¹ä¸ºå®æ—¶ä¿å­˜æ¨¡å¼');
    }

    // --- Core Logic ---
    async function initPython() {
        if (!pyodideInstance) pyodideInstance = await loadPyodide();
        return pyodideInstance;
    }

    function saveCurrentFile() {
        if (activeEditorTab && editorTabs[activeEditorTab]) {
            const editor = editorTabs[activeEditorTab].editor;
            const content = editor.value;
            
            // åˆ¤æ–­æ˜¯æ™®é€šæ–‡ä»¶è¿˜æ˜¯æ’ä»¶
            if (plugins.find(p => p.name === activeEditorTab)) {
                // ä¿å­˜ç°æœ‰æ’ä»¶
                const pluginIndex = plugins.findIndex(p => p.name === activeEditorTab);
                if (pluginIndex !== -1) {
                    plugins[pluginIndex].code = content;
                    savePlugins();
                    renderPlugins();
                }
            } else if (activeEditorTab === "New_Plugin") {
                // åˆ›å»ºæ–°æ’ä»¶
                if (content.trim()) {
                    plugins.push({ name: "New_Plugin", code: content, active: false });
                    savePlugins();
                    renderPlugins();
                }
            } else {
                // ä¿å­˜æ™®é€šæ–‡ä»¶
                storage[activeEditorTab] = content;
                localStorage.setItem('ind_console_storage', JSON.stringify(storage));
            }
            
            // ä¿å­˜å½“å‰æ´»åŠ¨æ ‡ç­¾
            localStorage.setItem('ind_console_active', activeEditorTab);
            localStorage.setItem('ind_console_expanded', JSON.stringify(expandedDirs));
            
            // æ˜¾ç¤ºä¿å­˜æˆåŠŸçš„æç¤º
            console.log(`æ–‡ä»¶ ${activeEditorTab} å·²ä¿å­˜`);
        }
    }
    
    function autoSave() {
        // ä¿ç•™å‡½æ•°ä½†ä¸å†è‡ªåŠ¨è°ƒç”¨
        // ç°åœ¨éœ€è¦æ‰‹åŠ¨ä¿å­˜
    }
    
    function openFile(fileName) {
        // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²ç»åœ¨æ ‡ç­¾ä¸­æ‰“å¼€
        if (editorTabs[fileName]) {
            // å¦‚æœå·²ç»æ‰“å¼€ï¼Œç›´æ¥åˆ‡æ¢åˆ°è¯¥æ ‡ç­¾
            switchEditorTab(fileName);
            return;
        }
        
        // åˆ›å»ºæ–°æ ‡ç­¾
        createEditorTab(fileName);
    }
    
    function createEditorTab(fileName) {
        // åˆ›å»ºæ ‡ç­¾
        const tab = document.createElement('div');
        tab.className = 'term-tab';
        tab.id = 'editor-tab-' + fileName;
        tab.innerHTML = `<span>${fileName}</span><span class="term-close" onclick="closeEditorTab('${fileName}')">Ã—</span>`;
        tab.onclick = () => switchEditorTab(fileName);
        
        // æ·»åŠ æ‹–æ‹½åŠŸèƒ½
        tab.setAttribute('draggable', 'true');
        tab.addEventListener('dragstart', handleTabDragStart);
        tab.addEventListener('dragover', handleTabDragOver);
        tab.addEventListener('drop', handleTabDrop);
        tab.addEventListener('dragend', handleTabDragEnd);
        
        document.getElementById('editor-tabs').appendChild(tab);
        
        // åˆ›å»ºç¼–è¾‘å™¨å†…å®¹åŒº
        const editorArea = document.createElement('textarea');
        editorArea.className = 'editor-body';
        editorArea.id = 'editor-' + fileName;
        editorArea.spellcheck = false;
        
        // åˆ¤æ–­æ˜¯æ™®é€šæ–‡ä»¶è¿˜æ˜¯æ’ä»¶
        if (plugins.find(p => p.name === fileName)) {
            // æ’ä»¶æ ‡ç­¾ï¼ˆç›´æ¥ä½¿ç”¨æ’ä»¶åï¼‰
            const plugin = plugins.find(p => p.name === fileName);
            editorArea.value = plugin ? plugin.code : '';
        } else {
            // æ™®é€šæ–‡ä»¶
            editorArea.value = storage[fileName] || '';
        }
        
        editorArea.style.display = 'none';
        editorArea.style.flex = '1';
        editorArea.style.resize = 'none';
        editorArea.style.border = 'none';
        editorArea.style.background = 'transparent';
        editorArea.style.color = 'inherit';
        editorArea.style.fontFamily = 'inherit';
        editorArea.style.fontSize = 'inherit';
        editorArea.style.padding = '10px';
        editorArea.style.outline = 'none';
        
        // æ·»åŠ å¿«æ·é”®æ”¯æŒ
        editorArea.onkeydown = function(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 's':
                        e.preventDefault();
                        saveCurrentFile();
                        break;
                    case 'z':
                        e.preventDefault();
                        document.execCommand('undo');
                        break;
                    case 'y':
                        e.preventDefault();
                        document.execCommand('redo');
                        break;
                }
            }
        };
        
        document.getElementById('editor-container').appendChild(editorArea);
        
        // ä¿å­˜æ ‡ç­¾ä¿¡æ¯
        editorTabs[fileName] = {
            tab: tab,
            editor: editorArea
        };
        
        // åˆ‡æ¢åˆ°æ–°æ ‡ç­¾
        switchEditorTab(fileName);
        initEditorTabEvents();
    }
    
    function switchEditorTab(fileName) {
        // éšè—æ‰€æœ‰ç¼–è¾‘å™¨
        Object.keys(editorTabs).forEach(tabName => {
            const editor = editorTabs[tabName].editor;
            editor.style.display = 'none';
            editorTabs[tabName].tab.classList.remove('active');
        });
        
        // æ˜¾ç¤ºå½“å‰ç¼–è¾‘å™¨
        if (editorTabs[fileName]) {
            editorTabs[fileName].editor.style.display = 'block';
            editorTabs[fileName].tab.classList.add('active');
            editorTabs[fileName].editor.focus();
            activeEditorTab = fileName;
            activeFile = fileName;
            localStorage.setItem('ind_console_active', fileName);
        }
    }
    
    function closeEditorTab(fileName) {
    const tabs = Object.keys(editorTabs);
    if (tabs.length <= 1) return; // è‡³å°‘ä¿ç•™ä¸€ä¸ªæ ‡ç­¾
    
    const tabInfo = editorTabs[fileName];
    const wasActive = tabInfo.tab.classList.contains('active');
    
    // åˆ é™¤DOMå…ƒç´ 
    tabInfo.tab.remove();
    tabInfo.editor.remove();
    
    // ä»æ ‡ç­¾ç®¡ç†ä¸­åˆ é™¤
    delete editorTabs[fileName];
    
    // å¦‚æœå…³é—­çš„æ˜¯å½“å‰æ´»åŠ¨æ ‡ç­¾ï¼Œåˆ‡æ¢åˆ°å…¶ä»–æ ‡ç­¾
    if (wasActive) {
        const remainingTabs = Object.keys(editorTabs);
        if (remainingTabs.length > 0) {
            switchEditorTab(remainingTabs[0]);
            initEditorTabEvents();
        }
    }
}

// æ ‡ç­¾æ‹–æ‹½åŠŸèƒ½
let draggedTab = null;

function handleTabDragStart(e) {
    draggedTab = this;
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', this.innerHTML);
    this.style.opacity = '0.4';
}

function handleTabDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    return false;
}

function handleTabDrop(e) {
    e.stopPropagation();
    e.preventDefault();
    
    if (draggedTab !== this) {
        // è·å–æ ‡ç­¾å®¹å™¨
        const tabsContainer = this.parentNode;
        const tabs = Array.from(tabsContainer.children);
        const fromIndex = tabs.indexOf(draggedTab);
        const toIndex = tabs.indexOf(this);
        
        // ç§»åŠ¨æ ‡ç­¾
        if (fromIndex < toIndex) {
            tabsContainer.insertBefore(draggedTab, this.nextSibling);
        } else {
            tabsContainer.insertBefore(draggedTab, this);
        }
        
        // æ ¹æ®æ ‡ç­¾ç±»å‹é‡æ–°æ’åºå¯¹åº”çš„å†…å®¹
        const tabType = tabsContainer.id;
        if (tabType === 'editor-tabs') {
            reorderEditorTabs();
        } else if (tabType === 'ai-tabs') {
            reorderAiTabs();
        } else if (tabType === 'term-tabs') {
            reorderTermTabs();
        }
    }
    
    return false;
}

function handleTabDragEnd(e) {
    this.style.opacity = '1';
    draggedTab = null;
}

function reorderEditorTabs() {
    const tabs = Array.from(document.getElementById('editor-tabs').children);
    const container = document.getElementById('editor-container');
    
    // é‡æ–°æ’åºç¼–è¾‘å™¨
    tabs.forEach(tab => {
        const fileName = tab.id.replace('editor-tab-', '');
        const editor = editorTabs[fileName].editor;
        container.appendChild(editor);
    });
}

function reorderAiTabs() {
    const tabs = Array.from(document.getElementById('ai-tabs').children);
    const container = document.getElementById('ai-container');
    
    // é‡æ–°æ’åºAIèŠå¤©çª—å£
    tabs.forEach(tab => {
        const chatId = tab.id.replace('tab-', '');
        const chatBody = document.getElementById(chatId);
        if (chatBody) {
            container.appendChild(chatBody);
        }
    });
}

function reorderTermTabs() {
    const tabs = Array.from(document.getElementById('term-tabs').children);
    const container = document.getElementById('term-container');
    
    // é‡æ–°æ’åºç»ˆç«¯çª—å£
    tabs.forEach(tab => {
        const termId = tab.id.replace('tab-', '');
        const termBody = document.getElementById(termId);
        if (termBody) {
            container.appendChild(termBody);
        }
    });
}

    function addLog(txt, color = 'var(--amber)') {
        if (activeTermId) {
            const output = document.getElementById(activeTermId).querySelector('.term-out');
            const d = document.createElement('div'); 
            d.style.color = color; 
            d.innerText = txt;
            output.appendChild(d); 
            output.scrollTop = output.scrollHeight;
        } else {
            console.log(txt);
        }
    }

    function initResizer(bar, target, isH, isInverse = false) {
        let dragging = false;
        bar.style.touchAction = 'none';

        const start = (e) => { 
            dragging = true; 
            bar.classList.add('active'); 
            if (e.cancelable) e.preventDefault(); 
        };

        const stop = () => { 
            dragging = false; 
            bar.classList.remove('active'); 
        };

        const move = (e) => {
            if (!dragging) return;
            let clientX, clientY;
            const touch = e.touches && e.touches[0];
            clientX = touch ? touch.clientX : e.clientX;
            clientY = touch ? touch.clientY : e.clientY;

            if (isH) {
                let p = (clientX / window.innerWidth) * 100;
                if (isInverse) p = 100 - p;
                p = Math.max(0, Math.min(100, p));
                target.style.width = p.toFixed(2) + '%'; 
                target.style.flex = "none"; 
            } else {
                let parentRect = target.parentNode.getBoundingClientRect();
                let p;
                if (isInverse) {
                    p = ((parentRect.bottom - clientY) / parentRect.height) * 100;
                } else {
                    p = ((clientY - parentRect.top) / parentRect.height) * 100;
                }
                p = Math.max(0, Math.min(99, p)); 
                
                target.style.height = p.toFixed(2) + '%';
                target.style.flex = "none"; 
                const nextEl = target.nextElementSibling?.classList.contains('divider-v') 
                               ? target.nextElementSibling.nextElementSibling 
                               : null;
                if (nextEl) {
                    nextEl.style.flex = "1";
                    nextEl.style.minHeight = "0px";
                }
            }
        };

        bar.addEventListener('mousedown', start);
        document.addEventListener('mousemove', move);
        document.addEventListener('mouseup', stop);
        bar.addEventListener('touchstart', start, { passive: false });
        document.addEventListener('touchmove', move, { passive: false });
        document.addEventListener('touchend', stop);
    }

    function toggleMax(id) {
    const el = document.getElementById(id);
    if (!el) return;
    
    // åˆ‡æ¢æœ€å¤§åŒ–ç±»å
    const isMax = el.classList.toggle('maximized');
    
    if (isMax) {
        // è¿›å…¥æœ€å¤§åŒ–ï¼šå¼ºåˆ¶ç§»é™¤ä¾§è¾¹æ å¯¹å…¶é«˜åº¦å’Œä¼¸ç¼©çš„é™åˆ¶
        // ä½¿ç”¨ dataset å¤‡ä»½åŸå§‹çš„è¡Œå†…æ ·å¼ï¼Œä»¥ä¾¿è¿˜åŸ
        el.dataset.origHeight = el.style.height;
        el.dataset.origFlex = el.style.flex;
        
        // å¼ºåˆ¶å…¨å±æ˜¾ç¤ºï¼Œ!important ç¡®ä¿è¦†ç›– HTML æ ‡ç­¾ä¸Šçš„ style="height: 50%"
        el.style.setProperty('height', '100vh', 'important');
        el.style.setProperty('flex', 'none', 'important');
        
        console.log(`Node ${id} å·²è¿›å…¥çœŸæ­£çš„å…¨å±æ¨¡å¼`);
    } else {
        // é€€å‡ºæœ€å¤§åŒ–ï¼šè¿˜åŸåŸå§‹è¡Œå†…æ ·å¼
        el.style.height = el.dataset.origHeight || '';
        el.style.flex = el.dataset.origFlex || '';
        
        console.log(`Node ${id} å·²æ¢å¤è‡³ä¾§è¾¹æ `);
    }
}

    function toggleExplorerMax(sectionId) {
        const explorer = document.getElementById('explorer');
        const fileSection = document.getElementById('file-section');
        const pluginSection = document.getElementById('plugin-section');
        const divider = document.getElementById('v-drag-explorer');
        
        // æ£€æŸ¥æ˜¯å¦å·²ç»æœ€å¤§åŒ–
        const isMax = explorer.classList.contains('maximized');
        
        if (isMax) {
            // é€€å‡ºæœ€å¤§åŒ–ï¼šè¿˜åŸæ‰€æœ‰æ ·å¼
            explorer.classList.remove('maximized');
            explorer.style.width = explorer.dataset.origWidth || '';
            explorer.style.flex = explorer.dataset.origFlex || '';
            
            // è¿˜åŸæ–‡ä»¶ç³»ç»Ÿå’Œæ’ä»¶ç³»ç»Ÿçš„æ˜¾ç¤º
            fileSection.style.display = 'flex';
            pluginSection.style.display = 'flex';
            divider.style.display = 'block';
            
            // æ˜¾ç¤ºå…¶ä»–é¢æ¿å’Œåˆ†å‰²çº¿
            document.getElementById('main-stack').style.display = 'flex';
            document.getElementById('h-drag-left').style.display = 'block';
            document.getElementById('h-drag-right').style.display = 'block';
            document.getElementById('ai-panel').style.display = 'flex';
            
            console.log(`Explorer å·²æ¢å¤`);
        } else {
            // è¿›å…¥æœ€å¤§åŒ–ï¼šå¤‡ä»½åŸå§‹æ ·å¼
            explorer.dataset.origWidth = explorer.style.width;
            explorer.dataset.origFlex = explorer.style.flex;
            
            // å¼ºåˆ¶å…¨å±æ˜¾ç¤º
            explorer.classList.add('maximized');
            explorer.style.setProperty('width', '100vw', 'important');
            explorer.style.setProperty('flex', 'none', 'important');
            
            // æ ¹æ®ç‚¹å‡»çš„sectionéšè—å¦ä¸€ä¸ªsection
            if (sectionId === 'file-section') {
                fileSection.style.display = 'flex';
                pluginSection.style.display = 'none';
                divider.style.display = 'none';
            } else if (sectionId === 'plugin-section') {
                fileSection.style.display = 'none';
                pluginSection.style.display = 'flex';
                divider.style.display = 'none';
            }
            
            // éšè—å…¶ä»–é¢æ¿å’Œåˆ†å‰²çº¿
            document.getElementById('main-stack').style.display = 'none';
            document.getElementById('h-drag-left').style.display = 'none';
            document.getElementById('h-drag-right').style.display = 'none';
            document.getElementById('ai-panel').style.display = 'none';
            
            console.log(`${sectionId} å·²è¿›å…¥å…¨å±æ¨¡å¼`);
        }
    }
    
    function renderFiles() {
        const list = document.getElementById('file-list');
        list.innerHTML = '';
        const sortedKeys = Object.keys(storage).sort((a,b) => {
            const aDir = a.includes('/') ? 0 : 1;
            const bDir = b.includes('/') ? 0 : 1;
            return aDir - bDir || a.localeCompare(b);
        });

        sortedKeys.forEach(k => {
            const isFolder = k.endsWith('/');
            const pathParts = k.split('/').filter(p => p);
            const depth = pathParts.length - 1;
            
            if (depth > 0) {
                let parentPath = "";
                for(let i=0; i<depth; i++) {
                    parentPath += pathParts[i] + "/";
                    if (!expandedDirs.includes(parentPath)) return;
                }
            }

            const div = document.createElement('div');
            div.className = `file-item ${k === activeFile ? 'active' : ''} ${isFolder ? 'folder' : ''}`;
            div.style.paddingLeft = (15 + depth * 15) + 'px';
            
            const nameSpan = document.createElement('span');
            nameSpan.innerText = pathParts[pathParts.length-1] + (isFolder ? '/' : '');
            div.appendChild(nameSpan);
            
            div.onclick = () => {
                autoSave();
                activeFile = k;
                if (isFolder) {
                    if (expandedDirs.includes(k)) {
                        expandedDirs = expandedDirs.filter(d => d !== k);
                    } else {
                        expandedDirs.push(k);
                    }
                } else {
                    openFile(k);
                }
                renderFiles();
            };
            
            div.oncontextmenu = (e) => {
                ctxTarget = { path: k, el: nameSpan, isFolder: isFolder };
                handleCtx(e);
            };
            list.appendChild(div);
        });
        updateAiCtxOptions();
    }

    function startRenameFromCtx() {
        if (!ctxTarget) return;
        document.getElementById('ctx').style.display = 'none';
        const { el, path, isFolder } = ctxTarget;
        const currentName = el.innerText.replace(/\/$/, '');
        const input = document.createElement('input');
        input.className = 'file-rename-input';
        input.value = currentName;
        el.parentNode.replaceChild(input, el);
        input.focus();
        input.onblur = () => {
            const newName = input.value.trim();
            if (newName && newName !== currentName) applyRename(path, newName, isFolder);
            else renderFiles();
        };
        input.onkeydown = (e) => { if (e.key === 'Enter') input.blur(); };
    }

    function applyRename(oldPath, newName, isFolder) {
        let newPath;
        const parts = oldPath.split('/');
        if (isFolder) {
            parts[parts.length - 2] = newName.replace(/\//g, '');
            newPath = parts.join('/');
            Object.keys(storage).forEach(key => {
                if (key.startsWith(oldPath)) {
                    storage[newPath + key.substring(oldPath.length)] = storage[key];
                    delete storage[key];
                }
            });
        } else {
            parts[parts.length - 1] = newName;
            newPath = parts.join('/');
            storage[newPath] = storage[oldPath];
            delete storage[oldPath];
        }
        if (activeFile === oldPath) activeFile = newPath;
        autoSave(); renderFiles();
    }

    function deleteNodeFromCtx() {
        if (!ctxTarget) return;
        const { path, isFolder } = ctxTarget;
        if (confirm(`PURGE NODE: ${path}?`)) {
            if (isFolder) {
                Object.keys(storage).forEach(k => {
                    if (k.startsWith(path)) delete storage[k];
                });
            } else {
                delete storage[path];
            }
            if (activeFile.startsWith(path)) {
                activeFile = Object.keys(storage).find(k => !k.endsWith('/')) || '';
                document.getElementById('editor').value = storage[activeFile] || "";
                document.getElementById('cur-filename').innerText = activeFile || "NO_NODE";
            }
            autoSave(); renderFiles();
        }
        document.getElementById('ctx').style.display = 'none';
    }

    function copyPathFromCtx() {
        if (ctxTarget) {
            navigator.clipboard.writeText(ctxTarget.path);
            document.getElementById('ctx').style.display = 'none';
        }
    }

    function updateAiCtxOptions() {
        const container = document.getElementById('ai-ctx-options');
        container.innerHTML = `<div onclick="selectAiCtx('none')">-- NO_CONTEXT --</div>`;
        Object.keys(storage).forEach(k => {
            if (!k.endsWith('/')) {
                const div = document.createElement('div');
                div.innerText = k;
                div.onclick = () => selectAiCtx(k);
                container.appendChild(div);
            }
        });
    }

    function selectAiCtx(val) {
        selectedAiCtx = val;
        document.getElementById('ai-ctx-val').innerText = val === 'none' ? '-- NO_CONTEXT --' : val;
        document.getElementById('ai-ctx-options').style.display = 'none';
    }

    function addTerminal() {
    const id = 'term-' + (++termCount);
    
    // åˆ›å»ºæ ‡ç­¾
    const tab = document.createElement('div');
    tab.className = 'term-tab';
    tab.id = 'tab-' + id;
    tab.innerHTML = `<span>TERM_${termCount}</span><span class="term-close" onclick="removeTerminal(event, '${id}')">Ã—</span>`;
    tab.onclick = () => switchTerminal(id);
    
    // æ·»åŠ æ‹–æ‹½åŠŸèƒ½
    tab.setAttribute('draggable', 'true');
    tab.addEventListener('dragstart', handleTabDragStart);
    tab.addEventListener('dragover', handleTabDragOver);
    tab.addEventListener('drop', handleTabDrop);
    tab.addEventListener('dragend', handleTabDragEnd);
    
    document.getElementById('term-tabs').appendChild(tab);
        const body = document.createElement('div');
        body.className = 'term-body'; body.id = id;
        body.innerHTML = `<div class="term-out">Terminal ${termCount} Ready.</div><div class="term-input-wrap"><span>>></span><input type="text" class="cmd-in" autocomplete="off" spellcheck="false"><button class="ai-btn" onclick="handleCommand('${id}')">SEND</button></div>`;
        body.querySelector('.cmd-in').onkeydown = (e) => { if(e.key === 'Enter') handleCommand(id); };
        document.getElementById('term-container').appendChild(body);
        switchTerminal(id);
    }

    function removeTerminal(e, id) {
        e.stopPropagation();
        const tabs = document.querySelectorAll('#term-tabs .term-tab'); 
        const tab = document.getElementById('tab-' + id);
        const body = document.getElementById(id);
        const wasActive = tab.classList.contains('active');
        
        tab.remove();
        body.remove();
        
        if (wasActive) {
            const nextTab = document.querySelector('#term-tabs .term-tab');
            if (nextTab) switchTerminal(nextTab.id.replace('tab-', ''));
        }
    }

    function switchTerminal(id) {
        document.querySelectorAll('.term-tab, .term-body').forEach(el => el.classList.remove('active'));
        document.getElementById('tab-' + id).classList.add('active');
        document.getElementById(id).classList.add('active');
        activeTermId = id;
        const input = document.getElementById(id).querySelector('.cmd-in');
        if(input) input.focus();
    }

    async function handleCommand(id) {
        const body = document.getElementById(id);
        const input = body.querySelector('.cmd-in');
        const output = body.querySelector('.term-out');
        const val = input.value.trim();
        if(!val) return;
        const log = (txt, color = 'rgba(255,176,0,0.8)') => {
            const d = document.createElement('div'); d.style.color = color; d.innerText = txt;
            output.appendChild(d); output.scrollTop = output.scrollHeight;
        };
        log(`>> ${val}`, '#fff');
        const args = val.split(' '), cmd = args[0].toLowerCase(), fileName = args[1];
        switch(cmd) {
            case 'help':
                log('AVAILABLE_COMMANDS: ls, cat, rm, touch, mkdir, pwd, echo, date, whoami, info, clear, node, python', 'var(--amber)');
                break;

            case 'cat': // æŸ¥çœ‹æ–‡ä»¶å†…å®¹
                if (storage[fileName]) log(storage[fileName]);
                else log(`ERR: NODE_NOT_FOUND: ${fileName}`, 'var(--term-red)');
                break;

            case 'touch': // åˆ›å»ºç©ºæ–‡ä»¶
                if (fileName) {
                    if (!storage[fileName]) {
                        storage[fileName] = "";
                        renderFiles();
                        log(`SUCCESS: NODE_CREATED: ${fileName}`, 'var(--term-green)');
                    } else {
                        log(`ERR: NODE_EXISTS`, 'var(--term-red)');
                    }
                }
                break;

            case 'mkdir': // åˆ›å»ºç›®å½•
                if (fileName) {
                    let dirName = fileName.endsWith('/') ? fileName : fileName + '/';
                    storage[dirName] = "DIR";
                    renderFiles();
                    log(`SUCCESS: DIR_CREATED: ${dirName}`, 'var(--term-green)');
                }
                break;

            case 'rm': // åˆ é™¤æ–‡ä»¶/ç›®å½•
                if (storage[fileName]) {
                    delete storage[fileName];
                    renderFiles();
                    log(`SUCCESS: NODE_PURGED: ${fileName}`, 'var(--term-red)');
                } else {
                    log(`ERR: NODE_NOT_FOUND`, 'var(--term-red)');
                }
                break;

            case 'pwd': // æ˜¾ç¤ºå½“å‰è·¯å¾„ (æ¨¡æ‹Ÿ)
                log(activeFile.includes('/') ? activeFile.substring(0, activeFile.lastIndexOf('/') + 1) : 'ROOT/');
                break;

            case 'echo': // è¾“å‡ºæ–‡æœ¬
                log(args.slice(1).join(' '));
                break;

            case 'date': // æ˜¾ç¤ºç³»ç»Ÿæ—¶é—´
                log(new Date().toString());
                break;

            case 'whoami': // ç”¨æˆ·ä¿¡æ¯
                log('IMMMOR_OPERATOR::ROOT', 'var(--amber)');
                break;

            case 'info': // å­˜å‚¨ç»Ÿè®¡
                const count = Object.keys(storage).length;
                const size = JSON.stringify(storage).length;
                log(`NODES: ${count} | TOTAL_SIZE: ${size} bytes | STATUS: OPTIMAL`);
                break;
            case 'ls': log(Object.keys(storage).join('    ')); break;
            case 'clear': output.innerHTML = ''; break;
            case 'node':
                try {
                    new Function('console', storage[fileName])({ log: (m) => log(m) });
                } catch (e) { log(`ERR: ${e.message}`, 'var(--term-red)'); }
                break;
            case 'python':
                const py = await initPython();
                py.setStdout({ batched: (str) => log(str, 'var(--term-green)') });
                await py.runPythonAsync(storage[fileName]);
                break;
            default: log(`ERR: UNKNOWN_CMD`, 'var(--term-red)');
        }
        input.value = '';
    }

    function openModal() {
        const isFolder = activeFile && activeFile.endsWith('/');
        const parentDir = activeFile ? (isFolder ? activeFile : (activeFile.includes('/') ? activeFile.substring(0, activeFile.lastIndexOf('/') + 1) : '')) : '';
        
        document.getElementById('modal-title').innerText = "NEW_NODE_CREATION";
        document.getElementById('modal-content').innerHTML = `
            <div style="font-size:9px; color:var(--amber-dim); margin-bottom:10px;">TARGET_PATH: ${parentDir || 'ROOT/'}</div>
            <div class="type-selector">
                <label class="type-opt"><input type="radio" name="ntype" value="file" checked> FILE</label>
                <label class="type-opt"><input type="radio" name="ntype" value="folder"> DIR</label>
            </div>
            <input type="text" id="modal-input" class="modal-input" placeholder="NAME" autocomplete="off">
            <div class="modal-btns">
                <button class="ai-btn" onclick="closeModal()">CANCEL</button>
                <button class="ai-btn" style="background:var(--amber); color:#000" onclick="confirmModal('${parentDir}')">CONFIRM</button>
            </div>`;
        document.getElementById('modal-overlay').style.display = 'flex';
        document.getElementById('modal-input').focus();
    }

    function confirmModal(parentDir) {
        let name = document.getElementById('modal-input').value.trim();
        const type = document.querySelector('input[name="ntype"]:checked').value;
        if (name) {
            let finalPath = parentDir + name;
            if (type === 'folder') { 
                if (!finalPath.endsWith('/')) finalPath += '/'; 
                storage[finalPath] = "DIR"; 
                activeFile = finalPath;
            } else { 
                storage[finalPath] = ""; 
                activeFile = finalPath;
                document.getElementById('editor').value = ""; 
                document.getElementById('cur-filename').innerText = finalPath;
            }
            renderFiles(); 
            autoSave(); 
            closeModal();
        }
    }

    function closeModal() { document.getElementById('modal-overlay').style.display = 'none'; }
    function toggleAiSelect() { 
    const opt = document.getElementById('ai-ctx-options');
    const trigger = document.getElementById('ai-ctx-trigger');
    
    // å…³é—­å¦ä¸€ä¸ªä¸‹æ‹‰æ¡†é˜²æ­¢é‡å 
    document.getElementById('ai-provider-options').style.display = 'none';
    document.getElementById('ai-provider-trigger').classList.remove('active');
    
    const isOpening = opt.style.display !== 'block';
    opt.style.display = isOpening ? 'block' : 'none';
    trigger.classList.toggle('active', isOpening);
}
    
    function openSettings() {
    document.getElementById('modal-title').innerText = "AI_PROVIDERS_CONFIG";
    
    let providersHtml = config.providers.map((p, i) => `
        <div style="border: 1px solid var(--amber-dim); padding: 10px; margin-bottom: 10px; position: relative;">
            <div style="font-size: 10px; margin-bottom: 5px; color: ${config.activeProviderIndex === i ? 'var(--term-green)' : 'var(--amber)'}">
                ${config.activeProviderIndex === i ? '[ACTIVE_NODE]' : 'NODE_' + i}
            </div>
            <input type="text" placeholder="NAME" class="modal-input" style="margin:2px 0" value="${p.name}" onchange="updateProvider(${i}, 'name', this.value)">
            <input type="text" placeholder="BASE_URL" class="modal-input" style="margin:2px 0" value="${p.apiBaseUrl}" onchange="updateProvider(${i}, 'apiBaseUrl', this.value)">
            <input type="text" placeholder="MODEL" class="modal-input" style="margin:2px 0" value="${p.model}" onchange="updateProvider(${i}, 'model', this.value)">
            <input type="password" placeholder="API_KEY" class="modal-input" style="margin:2px 0" value="${p.apiKey}" onchange="updateProvider(${i}, 'apiKey', this.value)">
            
            <div style="display:flex; gap: 10px; margin-top: 5px;">
                <button class="ai-btn" onclick="config.activeProviderIndex = ${i}; openSettings();">ACTIVATE</button>
                <button class="ai-btn" style="color:var(--term-red)" onclick="deleteProvider(${i})">DELETE</button>
            </div>
        </div>
    `).join('');

    document.getElementById('modal-content').innerHTML = `
        <div style="max-height: 400px; overflow-y: auto;">
            ${providersHtml}
            <button class="ai-btn" style="width:100%; border: 1px dashed var(--amber); margin-top:10px;" onclick="addProvider()">+ ADD_NEW_PROVIDER</button>
        </div>
        <div class="modal-btns">
            <button class="ai-btn" onclick="closeModal()">CLOSE</button>
            <button class="ai-btn" style="background:var(--amber); color:#000" onclick="saveSettings()">SAVE_TO_DISK</button>
        </div>`;
    document.getElementById('modal-overlay').style.display = 'flex';
}

// è¾…åŠ©ç®¡ç†å‡½æ•°
function updateProvider(index, field, value) {
    config.providers[index][field] = value;
}

function addProvider() {
    config.providers.push({ name: 'New Provider', apiBaseUrl: '', apiKey: '', model: '' });
    openSettings();
}

function deleteProvider(index) {
    if (config.providers.length <= 1) return alert("MINIMUM_ONE_PROVIDER_REQUIRED");
    config.providers.splice(index, 1);
    if (config.activeProviderIndex >= config.providers.length) config.activeProviderIndex = 0;
    openSettings();
}

function saveSettings() {
    localStorage.setItem('ind_console_config', JSON.stringify(config)); 
    closeModal();
}

function renderProviderOptions() {
    const container = document.getElementById('ai-provider-options');
    container.innerHTML = '';
    
    config.providers.forEach((p, i) => {
        const div = document.createElement('div');
        div.style.display = 'flex';
        div.style.justifyContent = 'space-between';
        
        const isChecked = selectedProviderIndices.includes(i);
        
        div.innerHTML = `
            <span>${isChecked ? '[X]' : '[ ]'} ${p.name}</span>
            <span style="font-size:8px; opacity:0.5">${p.model}</span>
        `;
        
        if (i === config.activeProviderIndex) div.style.color = 'var(--term-green)';

        div.onclick = (e) => {
            e.stopPropagation(); // é˜²æ­¢è§¦å‘å…¨å±€ç‚¹å‡»å…³é—­
            toggleProviderSelection(i);
        };
        container.appendChild(div);
    });
}

function toggleProviderSelection(index) {
    // åªæ”¯æŒå•ä¸ªä¾›åº”å•†ï¼Œç›´æ¥åˆ‡æ¢
    config.activeProviderIndex = index;
    selectedProviderIndices = [index];
    renderProviderOptions();
    updateProviderDisplay();
}

// ä¿®æ”¹æ˜¾ç¤ºæ–‡å­—ï¼Œæç¤ºé€‰ä¸­äº†å‡ ä¸ª
function updateProviderDisplay() {
    const el = document.getElementById('active-provider-name');
    if (!el) return;
    
    const p = config.providers[config.activeProviderIndex];
    el.innerText = p ? p.name : 'NONE';
    el.style.color = 'var(--term-green)';
}

function toggleProviderSelect() {
    const opt = document.getElementById('ai-provider-options');
    const trigger = document.getElementById('ai-provider-trigger');
    
    // å…³é—­å¦ä¸€ä¸ªä¸‹æ‹‰æ¡†é˜²æ­¢é‡å 
    document.getElementById('ai-ctx-options').style.display = 'none';
    document.getElementById('ai-ctx-trigger').classList.remove('active');
    
    const isOpening = opt.style.display !== 'block';
    opt.style.display = isOpening ? 'block' : 'none';
    trigger.classList.toggle('active', isOpening);
    
    if (isOpening) renderProviderOptions();
}

function selectProvider(index) {
    config.activeProviderIndex = index;
    localStorage.setItem('ind_console_config', JSON.stringify(config));
    updateProviderDisplay();
    document.getElementById('ai-provider-options').style.display = 'none';
    document.getElementById('ai-provider-trigger').classList.remove('active');
    addLog(`[SYSTEM]: SWITCHED_TO_PROVIDER >> ${config.providers[index].name}`, 'var(--term-green)');
}

    function newAiChat() {
        // å¼¹å‡ºç¡®è®¤æ¡†ï¼Œé˜²æ­¢è¯¯ç‚¹æ¸…ç©º
        if (confirm("START NEW CONVERSATION? (Current view will be cleared)")) {
            // åˆ›å»ºæ–°çš„èŠå¤©æ ‡ç­¾ï¼Œè€Œä¸æ˜¯æ¸…ç©ºå½“å‰æ ‡ç­¾
            addAiTab();
            
            // è‡ªåŠ¨èšç„¦åˆ°è¾“å…¥æ¡†
            document.getElementById('ai-in').focus();
        }
    }

    let aiCount = 0;
let activeAiId = null;

// é¡µé¢åŠ è½½æ—¶æ¢å¤èŠå¤©çª—å£
function restoreAiTabs() {
    // è·å–æ‰€æœ‰ä¿å­˜çš„èŠå¤©å†å²è®°å½•
    const savedChats = Object.keys(aiChatHistory);
    
    if (savedChats.length > 0) {
        // æ‰¾åˆ°æœ€å¤§çš„èŠå¤©IDæ¥ç¡®å®šaiCount
        const maxId = Math.max(...savedChats.map(id => parseInt(id.replace('ai-chat-', ''))));
        aiCount = maxId;
        
        // ä¸ºæ¯ä¸ªä¿å­˜çš„èŠå¤©è®°å½•åˆ›å»ºæ ‡ç­¾
        savedChats.forEach(chatId => {
            const idNum = parseInt(chatId.replace('ai-chat-', ''));
            
            // 1. åˆ›å»ºæ ‡ç­¾
            const tab = document.createElement('div');
            tab.className = 'term-tab'; 
            tab.id = 'tab-' + chatId;
            tab.innerHTML = `<span>CHAT_${idNum}</span><span class="term-close" onclick="removeAiTab(event, '${chatId}')">Ã—</span>`;
            tab.onclick = () => switchAiTab(chatId);
            document.getElementById('ai-tabs').appendChild(tab);

            // 2. åˆ›å»ºèŠå¤©å†…å®¹åŒº
            const body = document.createElement('div');
            body.className = 'term-body'; 
            body.id = chatId;
            body.style.padding = '15px';
            body.style.overflowY = 'auto';
            body.style.flex = '1';
            
            // åŠ è½½å†å²è®°å½•
            if (aiChatHistory[chatId] && aiChatHistory[chatId].length > 0) {
                body.innerHTML = aiChatHistory[chatId].join('');
            } else {
                body.innerHTML = `<div class="msg ai">SYSTEM: Session ${idNum} restored.</div>`;
            }
            
            document.getElementById('ai-container').appendChild(body);
        });
        
        // æ¿€æ´»ç¬¬ä¸€ä¸ªæ ‡ç­¾
        activeAiId = savedChats[0];
        switchAiTab(activeAiId);
    } else {
        // æ²¡æœ‰å†å²è®°å½•æ—¶åˆ›å»ºé»˜è®¤æ ‡ç­¾
        addAiTab(false);
    }
}

// --- AI å¤šæ ‡ç­¾é€»è¾‘ ---

function addAiTab(forceNew = true) {
    const id = 'ai-chat-' + (++aiCount);
    
    // 1. åˆ›å»ºæ ‡ç­¾ (å¤ç”¨ç»ˆç«¯æ ‡ç­¾æ ·å¼)
    const tab = document.createElement('div');
    tab.className = 'term-tab'; 
    tab.id = 'tab-' + id;
    const currentP = config.providers[config.activeProviderIndex];
    const label = currentP ? currentP.name.substring(0, 8) : aiCount;
    tab.innerHTML = `<span>CHAT_${aiCount}</span><span class="term-close" onclick="removeAiTab(event, '${id}')">Ã—</span>`;
    tab.onclick = () => switchAiTab(id);
    
    // æ·»åŠ æ‹–æ‹½åŠŸèƒ½
    tab.setAttribute('draggable', 'true');
    tab.addEventListener('dragstart', handleTabDragStart);
    tab.addEventListener('dragover', handleTabDragOver);
    tab.addEventListener('drop', handleTabDrop);
    tab.addEventListener('dragend', handleTabDragEnd);
    
    document.getElementById('ai-tabs').appendChild(tab);

    // 2. åˆ›å»ºèŠå¤©å†…å®¹åŒº (å¤ç”¨åŸæœ¬çš„ ai-chat ç»“æ„)
    const body = document.createElement('div');
    body.className = 'term-body'; // ä½¿ç”¨ term-body çš„ display:none é€»è¾‘
    body.id = id;
    body.style.padding = '15px';
    body.style.overflowY = 'auto';
    body.style.flex = '1';
    
    // æ£€æŸ¥æ˜¯å¦æœ‰å†å²è®°å½•ï¼Œå¦‚æœæœ‰åˆ™åŠ è½½ï¼Œå¦åˆ™æ˜¾ç¤ºåˆå§‹åŒ–æ¶ˆæ¯
    if (!forceNew && aiChatHistory[id] && aiChatHistory[id].length > 0) {
        body.innerHTML = aiChatHistory[id].join('');
    } else {
        body.innerHTML = `<div class="msg ai">SYSTEM: Session ${aiCount} initialized.</div>`;
        // å¦‚æœæ˜¯å¼ºåˆ¶æ–°å»ºï¼Œæ¸…ç©ºå†å²è®°å½•
        if (forceNew) {
            aiChatHistory[id] = [];
            localStorage.setItem('ind_console_ai_history', JSON.stringify(aiChatHistory));
        }
    }
    
    document.getElementById('ai-container').appendChild(body);
    
    activeAiId = id; 
    switchAiTab(id);
    return id;
}

function switchAiTab(id) {
    // ç§»é™¤æ‰€æœ‰ AI ç›¸å…³çš„ active ç±»
    document.querySelectorAll('#ai-tabs .term-tab').forEach(el => el.classList.remove('active'));
    document.querySelectorAll('#ai-container .term-body').forEach(el => el.classList.remove('active'));
    
    // æ¿€æ´»å½“å‰
    document.getElementById('tab-' + id).classList.add('active');
    const body = document.getElementById(id);
    body.classList.add('active');
    
    activeAiId = id;
    document.getElementById('ai-in').focus();
}

function removeAiTab(e, id) {
    e.stopPropagation();
    const tabs = document.querySelectorAll('#ai-tabs .term-tab');
    if (tabs.length <= 1) return; // è‡³å°‘ä¿ç•™ä¸€ä¸ª
    
    const tab = document.getElementById('tab-' + id);
    const body = document.getElementById(id);
    const wasActive = tab.classList.contains('active');
    
    // åˆ é™¤å¯¹åº”çš„å†å²è®°å½•
    delete aiChatHistory[id];
    localStorage.setItem('ind_console_ai_history', JSON.stringify(aiChatHistory));
    
    tab.remove();
    body.remove();
    
    if (wasActive) {
        const nextTab = document.querySelector('#ai-tabs .term-tab');
        if (nextTab) switchAiTab(nextTab.id.replace('tab-', ''));
    }
}

function openHistoryManager() {
    const modal = document.getElementById('modal-overlay');
    const modalContent = document.getElementById('modal-content');
    
    modal.style.display = 'flex';
    document.getElementById('modal-title').innerText = 'AI CONVERSATION HISTORY';
    
    // æ¸…ç©ºå†…å®¹
    modalContent.innerHTML = '';
    
    // åˆ›å»ºæ»šåŠ¨å®¹å™¨
    const scrollContainer = document.createElement('div');
    scrollContainer.style.maxHeight = '400px';
    scrollContainer.style.overflowY = 'auto';
    
    if (Object.keys(aiChatHistory).length === 0) {
        const emptyMsg = document.createElement('div');
        emptyMsg.style.textAlign = 'center';
        emptyMsg.style.padding = '20px';
        emptyMsg.style.opacity = '0.5';
        emptyMsg.textContent = 'No conversation history found.';
        scrollContainer.appendChild(emptyMsg);
    } else {
        Object.keys(aiChatHistory).forEach(chatId => {
            const idNum = parseInt(chatId.replace('ai-chat-', ''));
            const messages = aiChatHistory[chatId];
            const lastMessage = messages.length > 0 ? messages[messages.length - 1] : '';
            const preview = lastMessage.includes('>') ? 
                lastMessage.split('>')[1].substring(0, 50) + '...' : 
                lastMessage.substring(0, 50) + '...';
            
            // åˆ›å»ºå¯¹è¯æ¡ç›®å®¹å™¨
            const chatItem = document.createElement('div');
            chatItem.style.border = '1px solid var(--amber-dim)';
            chatItem.style.marginBottom = '10px';
            chatItem.style.padding = '10px';
            
            // åˆ›å»ºæ ‡é¢˜è¡Œ
            const header = document.createElement('div');
            header.style.display = 'flex';
            header.style.justifyContent = 'space-between';
            header.style.alignItems = 'center';
            header.style.marginBottom = '5px';
            
            const title = document.createElement('strong');
            title.textContent = `CHAT_${idNum}`;
            
            const buttons = document.createElement('div');
            
            const restoreBtn = document.createElement('button');
            restoreBtn.className = 'ai-btn';
            restoreBtn.style.fontSize = '9px';
            restoreBtn.style.padding = '2px 6px';
            restoreBtn.textContent = 'RESTORE';
            restoreBtn.onclick = () => restoreChat(chatId);
            
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'ai-btn';
            deleteBtn.style.fontSize = '9px';
            deleteBtn.style.padding = '2px 6px';
            deleteBtn.style.background = 'var(--term-red)';
            deleteBtn.textContent = 'DELETE';
            deleteBtn.onclick = () => deleteChat(chatId);
            
            buttons.appendChild(restoreBtn);
            buttons.appendChild(deleteBtn);
            
            header.appendChild(title);
            header.appendChild(buttons);
            
            // åˆ›å»ºé¢„è§ˆè¡Œ
            const previewDiv = document.createElement('div');
            previewDiv.style.fontSize = '10px';
            previewDiv.style.opacity = '0.7';
            previewDiv.textContent = `Last message: ${preview}`;
            
            // åˆ›å»ºæ¶ˆæ¯è®¡æ•°è¡Œ
            const countDiv = document.createElement('div');
            countDiv.style.fontSize = '9px';
            countDiv.style.opacity = '0.5';
            countDiv.textContent = `Messages: ${messages.length}`;
            
            chatItem.appendChild(header);
            chatItem.appendChild(previewDiv);
            chatItem.appendChild(countDiv);
            
            scrollContainer.appendChild(chatItem);
        });
    }
    
    modalContent.appendChild(scrollContainer);
    
    // åˆ›å»ºå…³é—­æŒ‰é’®å®¹å™¨
    const closeContainer = document.createElement('div');
    closeContainer.className = 'modal-btns';
    closeContainer.style.marginTop = '15px';
    closeContainer.style.textAlign = 'center';
    
    const closeBtn = document.createElement('button');
    closeBtn.className = 'ai-btn';
    closeBtn.textContent = 'CLOSE';
    closeBtn.onclick = closeModal;
    
    closeContainer.appendChild(closeBtn);
    modalContent.appendChild(closeContainer);
}

function restoreChat(chatId) {
    // æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨è¯¥èŠå¤©çª—å£
    const existingTab = document.getElementById('tab-' + chatId);
    if (!existingTab) {
        // ç¡®ä¿aiCountä¸æ¢å¤çš„èŠå¤©IDåŒæ­¥
        const idNum = parseInt(chatId.replace('ai-chat-', ''));
        if (idNum > aiCount) {
            aiCount = idNum;
        }
        
        // åˆ›å»ºæ–°çš„æ ‡ç­¾
        const tab = document.createElement('div');
        tab.className = 'term-tab'; 
        tab.id = 'tab-' + chatId;
        tab.innerHTML = `<span>CHAT_${idNum}</span><span class="term-close" onclick="removeAiTab(event, '${chatId}')">Ã—</span>`;
        tab.onclick = () => switchAiTab(chatId);
        document.getElementById('ai-tabs').appendChild(tab);

        // åˆ›å»ºèŠå¤©å†…å®¹åŒº
        const body = document.createElement('div');
        body.className = 'term-body'; 
        body.id = chatId;
        body.style.padding = '15px';
        body.style.overflowY = 'auto';
        body.style.flex = '1';
        
        // åŠ è½½å†å²è®°å½•
        if (aiChatHistory[chatId] && aiChatHistory[chatId].length > 0) {
            body.innerHTML = aiChatHistory[chatId].join('');
        }
        
        document.getElementById('ai-container').appendChild(body);
        
        // æ¿€æ´»è¯¥æ ‡ç­¾
        activeAiId = chatId;
        switchAiTab(chatId);
    }
    
    // å…³é—­ç®¡ç†çª—å£
    document.getElementById('modal-overlay').style.display = 'none';
}

function deleteChat(chatId) {
    if (confirm(`Permanently delete CHAT_${parseInt(chatId.replace('ai-chat-', ''))}? This action cannot be undone.`)) {
        // åˆ é™¤å†å²è®°å½•
        delete aiChatHistory[chatId];
        localStorage.setItem('ind_console_ai_history', JSON.stringify(aiChatHistory));
        
        // å¦‚æœè¯¥èŠå¤©çª—å£æ­£åœ¨æ˜¾ç¤ºï¼Œå…³é—­å®ƒ
        const existingTab = document.getElementById('tab-' + chatId);
        if (existingTab) {
            const tabs = document.querySelectorAll('#ai-tabs .term-tab');
            if (tabs.length > 1) {
                existingTab.remove();
                const chatBody = document.getElementById(chatId);
                if (chatBody) chatBody.remove();
                
                // åˆ‡æ¢åˆ°å…¶ä»–æ ‡ç­¾
                const nextTab = document.querySelector('#ai-tabs .term-tab');
                if (nextTab) switchAiTab(nextTab.id.replace('tab-', ''));
            }
        }
        
        // åˆ·æ–°ç®¡ç†ç•Œé¢
        openHistoryManager();
        addLog(`[SYSTEM]: Chat ${chatId} permanently deleted`, "var(--term-green)");
    }
}

function removeAiTab(e, id) {
    e.stopPropagation();
    const tabs = document.querySelectorAll('#ai-tabs .term-tab');
    if (tabs.length <= 1) return; // è‡³å°‘ä¿ç•™ä¸€ä¸ª
    
    const tab = document.getElementById('tab-' + id);
    const body = document.getElementById(id);
    const wasActive = tab.classList.contains('active');
    
    // æ³¨æ„ï¼šè¿™é‡Œä¸å†åˆ é™¤å†å²è®°å½•ï¼Œåªæ˜¯å…³é—­çª—å£
    tab.remove();
    body.remove();
    
    if (wasActive) {
        const nextTab = document.querySelector('#ai-tabs .term-tab');
        if (nextTab) switchAiTab(nextTab.id.replace('tab-', ''));
    }
}

async function handleAiSend() {
    const input = document.getElementById('ai-in');
    const query = input.value.trim();
    if (!query) return;

    // åªæ”¯æŒå•ä¸ªä¾›åº”å•†ï¼Œç›´æ¥å‘é€
    sendAi(null, activeAiId);
}

async function sendAi(overrideQuery = null, targetTabId = null) {
    const input = document.getElementById('ai-in');
    const query = (overrideQuery !== null) ? overrideQuery : input.value.trim();
    
    // ç¡®å®šä½¿ç”¨å“ªä¸ª IDï¼šä¼ äº†ç”¨ä¼ çš„ï¼Œæ²¡ä¼ ç”¨å…¨å±€æ´»è·ƒçš„
    const currentChatId = targetTabId || activeAiId;
    
    const provider = config.providers[config.activeProviderIndex];
    if (!query || !provider || !provider.apiKey || !currentChatId) return;

    // åªåœ¨å•æ¨¡å‹æ¨¡å¼ä¸‹æ¸…ç©ºè¾“å…¥æ¡†
    if (overrideQuery === null) {
        input.value = '';
    }

    const chat = document.getElementById(currentChatId);
    const uMsg = document.createElement('div');
    uMsg.className = 'msg user'; 
    uMsg.innerText = `[CTX:${selectedAiCtx}] > ${query}`;
    chat.appendChild(uMsg);
    
    // ç¼“å­˜ç”¨æˆ·æ¶ˆæ¯åˆ°å†å²è®°å½•
    if (!aiChatHistory[currentChatId]) {
        aiChatHistory[currentChatId] = [];
    }
    aiChatHistory[currentChatId].push(uMsg.outerHTML);

    const aiMsg = document.createElement('div');
    aiMsg.className = 'msg ai'; 
    aiMsg.innerText = 'AI: connecting...';
    chat.appendChild(aiMsg); 
    
    const scrollChat = () => chat.scrollTo({ top: chat.scrollHeight, behavior: 'smooth' });
    scrollChat();

    try {
        const response = await fetch(`${provider.apiBaseUrl}/chat/completions`, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json', 
                'Authorization': `Bearer ${provider.apiKey}` 
            },
            body: JSON.stringify({ 
                model: provider.model, 
                messages: [{ 
                    role: 'user', 
                    content: selectedAiCtx !== 'none' ? `Context: ${storage[selectedAiCtx]}\n\nQuery: ${query}` : query 
                }],
                stream: false
            })
        });

        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const data = await response.json();
        const fullContent = data.choices[0].message.content;
        
        aiMsg.innerText = 'AI: ';
        let charIndex = 0;
        const typingTimer = setInterval(() => {
            aiMsg.innerText += fullContent[charIndex];
            charIndex++;
            scrollChat();
            if (charIndex >= fullContent.length) {
                clearInterval(typingTimer);
                
                // ç¼“å­˜AIå›å¤åˆ°å†å²è®°å½•
                aiChatHistory[currentChatId].push(aiMsg.outerHTML);
                localStorage.setItem('ind_console_ai_history', JSON.stringify(aiChatHistory));
                
                if (fullContent.includes('```')) {
                    const btn = document.createElement('div');
                    btn.className = 'inject-btn'; 
                    btn.innerText = '>> EXTRACT_CODE';
                    btn.onclick = () => {
                        const code = fullContent.split('```')[1].split('\n').slice(1).join('\n');
                        document.getElementById('editor').value += "\n" + code;
                        autoSave();
                    };
                    aiMsg.appendChild(document.createElement('br'));
                    aiMsg.appendChild(btn);
                    scrollChat();
                }
            }
        }, 10);
    } catch (err) { 
        aiMsg.innerText = `AI: [ERR]: ${err.message}`; 
        scrollChat();
    }
}

function handleExtractButton(container) {
    const text = container.innerText;
    if (text.includes('```')) {
        const btn = document.createElement('div');
        btn.className = 'inject-btn'; 
        btn.innerText = '>> EXTRACT_CODE';
        btn.onclick = () => { 
            const code = text.split('```')[1].split('\n').slice(1).join('\n');
            document.getElementById('editor').value += "\n" + code; 
            autoSave(); 
        };
        container.appendChild(document.createElement('br')); 
        container.appendChild(btn);
    }
}
    function handleCtx(e, x, y) {
        e.preventDefault();
        const ctxMenu = document.getElementById('ctx');
        const isItem = e.target.closest('.file-item');
        document.getElementById('ctx-rename').classList.toggle('disabled', !isItem);
        document.getElementById('ctx-delete').classList.toggle('disabled', !isItem);
        document.getElementById('ctx-copy-path').classList.toggle('disabled', !isItem);
        ctxMenu.style.display = 'block'; ctxMenu.style.left = (x || e.pageX) + 'px'; ctxMenu.style.top = (y || e.pageY) + 'px';
    }

    async function saveZip() {
        const zip = new JSZip(); 
        Object.keys(storage).forEach(k => { if(!k.endsWith('/')) zip.file(k, storage[k]); });
        const b = await zip.generateAsync({type:"blob"}), a = document.createElement('a');
        a.href = URL.createObjectURL(b); a.download = "archive.zip"; a.click();
    }
    
    function saveActive() { 
        const b = new Blob([document.getElementById('editor').value], {type:'text/plain'}), a = document.createElement('a');
        a.href = URL.createObjectURL(b); a.download = activeFile.split('/').pop(); a.click(); 
    }
    
    function clearTerm() { if(activeTermId) document.getElementById(activeTermId).querySelector('.term-out').innerHTML = 'READY.'; }

    // --- Init ---
    initResizer(document.getElementById('h-drag-left'), document.getElementById('explorer'), true, false);
    // æ–‡ä»¶åˆ—è¡¨ï¼šæ­£å¸¸æ–¹å‘ (å¾€ä¸‹æ‹–å˜å¤§)
    initResizer(document.getElementById('v-drag-explorer'), document.getElementById('file-section'), false, false);
    // AI é¢æ¿ï¼šåå‘ (å¾€å·¦æ‹–å˜å¤§)
    initResizer(document.getElementById('h-drag-right'), document.getElementById('ai-panel'), true, true);
    // ç»ˆç«¯é¢æ¿ï¼šåå‘ (å¾€ä¸Šæ‹–å˜å¤§)
    initResizer(document.getElementById('v-drag'), document.getElementById('terminal'), false, true);
    
    document.addEventListener('click', (e) => {
    if (!document.getElementById('ctx').contains(e.target)) document.getElementById('ctx').style.display = 'none';
    if (!document.getElementById('plugin-ctx').contains(e.target)) document.getElementById('plugin-ctx').style.display = 'none';
    
    // è‡ªåŠ¨å…³é—­ AI ç›¸å…³çš„ä¸‹æ‹‰èœå•
    if (!document.getElementById('ai-ctx-trigger').contains(e.target)) {
        document.getElementById('ai-ctx-options').style.display = 'none';
    }
    if (!document.getElementById('ai-provider-trigger').contains(e.target)) {
        document.getElementById('ai-provider-options').style.display = 'none';
    }
});
    document.getElementById('ai-in').onkeydown = (e) => { if(e.key === 'Enter') sendAi(); };

    renderFiles(); renderPlugins(); addTerminal(); restoreAiTabs(); updateProviderDisplay();
    // åˆå§‹åŒ–ç¼–è¾‘å™¨æ ‡ç­¾
    createEditorTab(activeFile);
</script>
</body>
</html>