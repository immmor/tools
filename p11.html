<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>像素平移去水印工具</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background: #f0f2f5; }
        .controls { margin: 20px; padding: 15px; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        canvas { border: 1px solid #ccc; cursor: crosshair; background-color: #fff; max-width: 100%; }
        .canvas-container { position: relative; }
        button { padding: 8px 16px; cursor: pointer; background: #007bff; color: white; border: none; border-radius: 4px; }
        button:hover { background: #0056b3; }
        input[type="range"] { vertical-align: middle; }
    </style>
</head>
<body>

    <h2>像素平移去水印工具</h2>

    <div class="controls">
        <input type="file" id="upload" accept="image/*">
        <label>画笔大小: </label>
        <input type="range" id="brushSize" min="5" max="50" value="15">
        <label>平移偏移量: </label>
        <input type="range" id="offset" min="1" max="20" value="5">
        <button id="download">下载结果</button>
        <p><small>说明：点击并涂抹水印，像素将根据你的笔触方向从周边平移覆盖。</small></p>
    </div>

    <div class="canvas-container">
        <canvas id="mainCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const upload = document.getElementById('upload');
        const brushSizeInput = document.getElementById('brushSize');
        const offsetInput = document.getElementById('offset');
        const downloadBtn = document.getElementById('download');

        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let img = new Image();

        // 1. 加载图片
        upload.addEventListener('change', (e) => {
            const reader = new FileReader();
            reader.onload = (event) => {
                img.onload = () => {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(e.target.files[0]);
        });

        // 2. 交互逻辑
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            [lastX, lastY] = getMousePos(e);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            const [currX, currY] = getMousePos(e);
            
            // 执行像素平移算法
            shiftPixels(lastX, lastY, currX, currY);
            
            [lastX, lastY] = [currX, currY];
        });

        window.addEventListener('mouseup', () => isDrawing = false);

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return [
                (e.clientX - rect.left) * scaleX,
                (e.clientY - rect.top) * scaleY
            ];
        }

        // 3. 核心算法：基于笔触方向的像素平移
        function shiftPixels(x1, y1, x2, y2) {
            const brushSize = parseInt(brushSizeInput.value);
            const offset = parseInt(offsetInput.value);

            // 计算移动方向向量
            const dx = x2 - x1;
            const dy = y2 - y1;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance === 0) return;

            // 归一化方向并取反（我们要取后面的像素来填补前面的位置）
            const ux = dx / distance;
            const uy = dy / distance;

            // 获取当前笔刷范围内的像素数据
            // 为了简化演示，我们直接在 Canvas 上通过 getImageData 实时操作
            // 这种方法能即时看到“涂抹”效果
            const radius = brushSize;
            
            // 我们以当前点为圆心，将 offset 距离外的像素平移过来
            // 这里使用一个简单的局部覆盖
            ctx.save();
            ctx.beginPath();
            ctx.arc(x2, y2, radius, 0, Math.PI * 2);
            ctx.clip();

            // 关键动作：将偏移位置的图像绘制到当前位置
            // 绘制偏移：即把 (x - ux*offset, y - uy*offset) 处的图像移动到 (x, y)
            ctx.drawImage(
                canvas, 
                x2 - ux * offset - radius, y2 - uy * offset - radius, radius * 2, radius * 2, // 源矩形
                x2 - radius, y2 - radius, radius * 2, radius * 2 // 目标矩形
            );
            ctx.restore();
        }

        // 下载功能
        downloadBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'removed_watermark.png';
            link.href = canvas.toDataURL();
            link.click();
        });
    </script>
</body>
</html>